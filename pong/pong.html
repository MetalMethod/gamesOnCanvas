<!DOCTYPE html>
<html lang="en">
<head>
	<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
	<meta content="utf-8" http-equiv="encoding">
</head>

<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        let canvas, canvasContext, rect;

		const INITIAL_BALL_SPEED = 10;
        const PADDLE_WIDTH = 10;
        const PADDLE_HEIGHT = 100;
        const PADDLE_PADDING = PADDLE_WIDTH * 2;
        const PADDLE_HALF = PADDLE_HEIGHT/2;
        const PADDLE_REFLECTION_FIX = 0.35;
        const MIDDLELINE_SIZE = PADDLE_HEIGHT / 2;

		let ballSize = 10;
        let ballX = 400;
        let ballY = 300;
        let ballSpeedX = INITIAL_BALL_SPEED;
        let ballSpeedY = INITIAL_BALL_SPEED;

        let paddleOneX = PADDLE_PADDING;
        let paddleOneY = 300 - PADDLE_HALF;

		let paddleTwoX = 800 - PADDLE_PADDING ;
        let paddleTwoY = 300 - PADDLE_HALF;

         let paddleTopEdgeY, paddleBottomEdgeY, paddleLeftEdgeX, paddleRightEdgeX;

        window.onload = function() {
            canvas = document.getElementById('gameCanvas');
            canvasContext = canvas.getContext('2d');

            rect = canvas.getBoundingClientRect();

            let framesPerSecond = 30;
            setInterval(updateAll, 1000/framesPerSecond);

            canvas.addEventListener('mousemove', updateMousePos);
        }

         function updateMousePos(evt){
            let root = document.documentElement;

            let mouseX = evt.clientX - rect.left - root.scrollLeft;
            let mouseY = evt.clientY - rect.top - root.scrollTop;

            paddleOneY = mouseY - PADDLE_HALF;
        //console.log('paddleX ', paddleOneX , 'mouseX ', mouseX);
        }

        function updateAll(){
            moveAll();
            drawAll();
        }

        function ballReset(){
            ballX = canvas.width/2;
            ballY = canvas.height/2
            // ballSpeedX *= -1;
        }

        function moveAll(){
            ballX += ballSpeedX;
            ballY += ballSpeedY;

            detectBallOnWalls();
            blockPaddlesOutsideCanvas();
            
            //collisionDetect(paddleTopEdgeY, paddleBottomEdgeY, paddleLeftEdgeX, paddleRightEdgeX);
            collisionDetect();
        }

        function drawAll(){
            // background box
            colorRect(0,0, canvas.width, canvas.height, 'black');

            drawMiddleLine();
            
            colorCircle(ballX,ballY, ballSize, 'white');

            colorRect(paddleOneX, paddleOneY, PADDLE_WIDTH ,PADDLE_HEIGHT, 'white');
			colorRect(paddleTwoX, paddleTwoY, PADDLE_WIDTH ,PADDLE_HEIGHT, 'white');
        }

        function colorRect(topLeftX,topleftY, boxWidth,boxHeight, fillColor){
            canvasContext.fillStyle = fillColor;
            canvasContext.fillRect(topLeftX,topleftY, boxWidth,boxHeight);
        }

        function colorCircle(centerX,centerY, radius, fillColor){
            canvasContext.fillStyle =  fillColor;
            canvasContext.beginPath();
            canvasContext.arc(centerX, centerY, radius , 0, Math.PI*2, true);
            canvasContext.fill();
        }

        //function collisionDetect(paddleTopEdgeY, paddleBottomEdgeY, paddleLeftEdgeX, paddleRightEdgeX){
        function collisionDetect(){
            paddleTopEdgeY = paddleOneY - PADDLE_HALF ;
            paddleBottomEdgeY = paddleTopEdgeY + PADDLE_HEIGHT;
            paddleLeftEdgeX = paddleOneX;
            paddleRightEdgeX = paddleOneX + PADDLE_WIDTH;

//console.log('ballX',ballX, 'ballY',ballY ,'paddleTopEdgeY', paddleTopEdgeY, 'paddleBottomEdgeY', paddleBottomEdgeY);

            if(ballX > paddleLeftEdgeX && ballX < paddleRightEdgeX && ballY > paddleTopEdgeY && ballY < paddleBottomEdgeY){
                    //console.log('COLLISION! dist ' , ballDistFromPaddleCenterY);
					console.log('COLLISION!');
                    ballSpeedX *= -1;
                    // let ballDistFromPaddleCenterY = ballY - paddleOneY;
                    // ballSpeedY = ballDistFromPaddleCenterY * PADDLE_REFLECTION_FIX;
                }
        }

        function detectBallOnWalls(){
            if(ballX < ballSize){ // left
				ballSpeedX *= -1;
                // ballReset();
            }
            if(ballX > canvas.width - ballSize){ // right
                ballSpeedX *= -1;
			//		ballReset();
            }
            if(ballY < ballSize){ // top
                ballSpeedY *= -1;
            }
            if(ballY > canvas.height - ballSize * 2){ // bottom
                ballSpeedY *= -1;
            }
        }

        // blocks both paddles if they go outside canvas
        function blockPaddlesOutsideCanvas(){
            // top
            if( paddleOneY < PADDLE_PADDING){
                paddleOneY = PADDLE_PADDING;
            }
            // bottom
            if( paddleOneY > canvas.height - PADDLE_HEIGHT - PADDLE_PADDING){
                paddleOneY = canvas.height - PADDLE_HEIGHT -PADDLE_PADDING
            }
            // top
            if( paddleTwoY < PADDLE_PADDING){
                paddleTwoY = PADDLE_PADDING;
            }
            // bottom
            if( paddleTwoY > canvas.height - PADDLE_HEIGHT - PADDLE_PADDING){
                paddleTwoY = canvas.height - PADDLE_HEIGHT -PADDLE_PADDING
            }
        }

        // Draws the middle line on the canvas
        function drawMiddleLine(){
            for(let i = 0; i < canvas.height; i = i + MIDDLELINE_SIZE){
                colorRect(canvas.width/2, i, 2 , MIDDLELINE_SIZE / 2, '#666');
            }
        }

    </script>
</body>
</html>